<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Anti-debug introduction | x64.moe</title>
<meta name=keywords content><meta name=description content='Anti-debug
アンチデバッグのやり方はたくさんあるが、その中でもよく使われるものを紹介する。
網羅的に把握したい場合は下記リンクを参照すると良い。
https://unprotect.it/category/anti-debugging/
古典的なアンチデバッグ
bool FindDebugger() {
  bool bDetect = false;
  HWND hDebugger = ::FindWindow(NULL, "OllyDBG");
  if (hDebugger) {
    bDetect = true;
    AfxMessageBox("Can not use debugger");
  }
  return bDetect;
}
デバッガーのウィンドウキャプションを見つけてプログラムを終了させる。
IsDebuggerPresent
MSDNに記載されていてkernel32.dllから提供されている。
if (IsDebuggerPresent()) {
  exit(1);
}
アセンブリになると下記のようになる
mov eax, dword ptf fs:[18]
mov eax, dword ptr ds:[eax+30]
movzx eax, byte ptr ds:[eax+2]
retn
fs:[18] はTEBを指す。(Thread Environment Block)
TEBをEAXに入れたがそこから30番地離れたアドレスを再びEAXに入力するコードだ。
TEBから0x30離れたところにはPEB(Process Environment Block) がある。
EAXにはPEBが入っていて、そこから+2移動したアドレスから1バイト持ってきていると解釈できる。
PEBの構造体は下記の通り。
typedef struct _PEB {
  BYTE                          Reserved1[2];
  BYTE                          BeingDebugged;
  BYTE                          Reserved2[1];
  PVOID                         Reserved3[2];
  PPEB_LDR_DATA                 Ldr;
  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
  PVOID                         Reserved4[3];
  PVOID                         AtlThunkSListPtr;
  PVOID                         Reserved5;
  ULONG                         Reserved6;
  PVOID                         Reserved7;
  ULONG                         Reserved8;
  ULONG                         AtlThunkSListPtr32;
  PVOID                         Reserved9[45];
  BYTE                          Reserved10[96];
  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
  BYTE                          Reserved11[128];
  PVOID                         Reserved12[1];
  ULONG                         SessionId;
} PEB, *PPEB;
BeingDebugged という名前の箇所の値を入れている。
ここにtrueが入っているとデバッグ中であり、falseが入っているとデバッグ中ではないことを表現する。
NtQueryInformationProcess
ntdll.dllにエクスポートされている NtQueryInformationProcess() というネイティブAPIを利用した方法を書く。
デバッグポートをチェックする方法と呼ばれる。
デバッグポートはカーネルで管理する EPROCESS 構造体の DebugPort フラグで有効にされ、 NtQueryInformationProcess はその値を取得する。'><meta name=author content="FAMASoon"><link rel=canonical href=https://famasoon.github.io/posts/antidebug/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://famasoon.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://famasoon.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://famasoon.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://famasoon.github.io/apple-touch-icon.png><link rel=mask-icon href=https://famasoon.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://famasoon.github.io/posts/antidebug/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZJPXHR8YPR"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZJPXHR8YPR")}</script><meta property="og:title" content="Anti-debug introduction"><meta property="og:description" content='Anti-debug
アンチデバッグのやり方はたくさんあるが、その中でもよく使われるものを紹介する。
網羅的に把握したい場合は下記リンクを参照すると良い。
https://unprotect.it/category/anti-debugging/
古典的なアンチデバッグ
bool FindDebugger() {
  bool bDetect = false;
  HWND hDebugger = ::FindWindow(NULL, "OllyDBG");
  if (hDebugger) {
    bDetect = true;
    AfxMessageBox("Can not use debugger");
  }
  return bDetect;
}
デバッガーのウィンドウキャプションを見つけてプログラムを終了させる。
IsDebuggerPresent
MSDNに記載されていてkernel32.dllから提供されている。
if (IsDebuggerPresent()) {
  exit(1);
}
アセンブリになると下記のようになる
mov eax, dword ptf fs:[18]
mov eax, dword ptr ds:[eax+30]
movzx eax, byte ptr ds:[eax+2]
retn
fs:[18] はTEBを指す。(Thread Environment Block)
TEBをEAXに入れたがそこから30番地離れたアドレスを再びEAXに入力するコードだ。
TEBから0x30離れたところにはPEB(Process Environment Block) がある。
EAXにはPEBが入っていて、そこから+2移動したアドレスから1バイト持ってきていると解釈できる。
PEBの構造体は下記の通り。
typedef struct _PEB {
  BYTE                          Reserved1[2];
  BYTE                          BeingDebugged;
  BYTE                          Reserved2[1];
  PVOID                         Reserved3[2];
  PPEB_LDR_DATA                 Ldr;
  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
  PVOID                         Reserved4[3];
  PVOID                         AtlThunkSListPtr;
  PVOID                         Reserved5;
  ULONG                         Reserved6;
  PVOID                         Reserved7;
  ULONG                         Reserved8;
  ULONG                         AtlThunkSListPtr32;
  PVOID                         Reserved9[45];
  BYTE                          Reserved10[96];
  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
  BYTE                          Reserved11[128];
  PVOID                         Reserved12[1];
  ULONG                         SessionId;
} PEB, *PPEB;
BeingDebugged という名前の箇所の値を入れている。
ここにtrueが入っているとデバッグ中であり、falseが入っているとデバッグ中ではないことを表現する。
NtQueryInformationProcess
ntdll.dllにエクスポートされている NtQueryInformationProcess() というネイティブAPIを利用した方法を書く。
デバッグポートをチェックする方法と呼ばれる。
デバッグポートはカーネルで管理する EPROCESS 構造体の DebugPort フラグで有効にされ、 NtQueryInformationProcess はその値を取得する。'><meta property="og:type" content="article"><meta property="og:url" content="https://famasoon.github.io/posts/antidebug/"><meta property="og:image" content="https://famasoon.github.io/static/famasoon.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-12T00:00:00+00:00"><meta property="article:modified_time" content="2023-10-12T00:00:00+00:00"><meta property="og:site_name" content="x64.moe"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://famasoon.github.io/static/famasoon.jpg"><meta name=twitter:title content="Anti-debug introduction"><meta name=twitter:description content='Anti-debug
アンチデバッグのやり方はたくさんあるが、その中でもよく使われるものを紹介する。
網羅的に把握したい場合は下記リンクを参照すると良い。
https://unprotect.it/category/anti-debugging/
古典的なアンチデバッグ
bool FindDebugger() {
  bool bDetect = false;
  HWND hDebugger = ::FindWindow(NULL, "OllyDBG");
  if (hDebugger) {
    bDetect = true;
    AfxMessageBox("Can not use debugger");
  }
  return bDetect;
}
デバッガーのウィンドウキャプションを見つけてプログラムを終了させる。
IsDebuggerPresent
MSDNに記載されていてkernel32.dllから提供されている。
if (IsDebuggerPresent()) {
  exit(1);
}
アセンブリになると下記のようになる
mov eax, dword ptf fs:[18]
mov eax, dword ptr ds:[eax+30]
movzx eax, byte ptr ds:[eax+2]
retn
fs:[18] はTEBを指す。(Thread Environment Block)
TEBをEAXに入れたがそこから30番地離れたアドレスを再びEAXに入力するコードだ。
TEBから0x30離れたところにはPEB(Process Environment Block) がある。
EAXにはPEBが入っていて、そこから+2移動したアドレスから1バイト持ってきていると解釈できる。
PEBの構造体は下記の通り。
typedef struct _PEB {
  BYTE                          Reserved1[2];
  BYTE                          BeingDebugged;
  BYTE                          Reserved2[1];
  PVOID                         Reserved3[2];
  PPEB_LDR_DATA                 Ldr;
  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
  PVOID                         Reserved4[3];
  PVOID                         AtlThunkSListPtr;
  PVOID                         Reserved5;
  ULONG                         Reserved6;
  PVOID                         Reserved7;
  ULONG                         Reserved8;
  ULONG                         AtlThunkSListPtr32;
  PVOID                         Reserved9[45];
  BYTE                          Reserved10[96];
  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
  BYTE                          Reserved11[128];
  PVOID                         Reserved12[1];
  ULONG                         SessionId;
} PEB, *PPEB;
BeingDebugged という名前の箇所の値を入れている。
ここにtrueが入っているとデバッグ中であり、falseが入っているとデバッグ中ではないことを表現する。
NtQueryInformationProcess
ntdll.dllにエクスポートされている NtQueryInformationProcess() というネイティブAPIを利用した方法を書く。
デバッグポートをチェックする方法と呼ばれる。
デバッグポートはカーネルで管理する EPROCESS 構造体の DebugPort フラグで有効にされ、 NtQueryInformationProcess はその値を取得する。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://famasoon.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Anti-debug introduction","item":"https://famasoon.github.io/posts/antidebug/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Anti-debug introduction","name":"Anti-debug introduction","description":"Anti-debug アンチデバッグのやり方はたくさんあるが、その中でもよく使われるものを紹介する。\n網羅的に把握したい場合は下記リンクを参照すると良い。\nhttps://unprotect.it/category/anti-debugging/\n古典的なアンチデバッグ bool FindDebugger() { bool bDetect = false; HWND hDebugger = ::FindWindow(NULL, \u0026#34;OllyDBG\u0026#34;); if (hDebugger) { bDetect = true; AfxMessageBox(\u0026#34;Can not use debugger\u0026#34;); } return bDetect; } デバッガーのウィンドウキャプションを見つけてプログラムを終了させる。\nIsDebuggerPresent MSDNに記載されていてkernel32.dllから提供されている。\nif (IsDebuggerPresent()) { exit(1); } アセンブリになると下記のようになる\nmov eax, dword ptf fs:[18] mov eax, dword ptr ds:[eax+30] movzx eax, byte ptr ds:[eax+2] retn fs:[18] はTEBを指す。(Thread Environment Block)\nTEBをEAXに入れたがそこから30番地離れたアドレスを再びEAXに入力するコードだ。\nTEBから0x30離れたところにはPEB(Process Environment Block) がある。\nEAXにはPEBが入っていて、そこから+2移動したアドレスから1バイト持ってきていると解釈できる。\nPEBの構造体は下記の通り。\ntypedef struct _PEB { BYTE Reserved1[2]; BYTE BeingDebugged; BYTE Reserved2[1]; PVOID Reserved3[2]; PPEB_LDR_DATA Ldr; PRTL_USER_PROCESS_PARAMETERS ProcessParameters; PVOID Reserved4[3]; PVOID AtlThunkSListPtr; PVOID Reserved5; ULONG Reserved6; PVOID Reserved7; ULONG Reserved8; ULONG AtlThunkSListPtr32; PVOID Reserved9[45]; BYTE Reserved10[96]; PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine; BYTE Reserved11[128]; PVOID Reserved12[1]; ULONG SessionId; } PEB, *PPEB; BeingDebugged という名前の箇所の値を入れている。\nここにtrueが入っているとデバッグ中であり、falseが入っているとデバッグ中ではないことを表現する。\nNtQueryInformationProcess ntdll.dllにエクスポートされている NtQueryInformationProcess() というネイティブAPIを利用した方法を書く。\nデバッグポートをチェックする方法と呼ばれる。\nデバッグポートはカーネルで管理する EPROCESS 構造体の DebugPort フラグで有効にされ、 NtQueryInformationProcess はその値を取得する。\n","keywords":[],"articleBody":"Anti-debug アンチデバッグのやり方はたくさんあるが、その中でもよく使われるものを紹介する。\n網羅的に把握したい場合は下記リンクを参照すると良い。\nhttps://unprotect.it/category/anti-debugging/\n古典的なアンチデバッグ bool FindDebugger() { bool bDetect = false; HWND hDebugger = ::FindWindow(NULL, \"OllyDBG\"); if (hDebugger) { bDetect = true; AfxMessageBox(\"Can not use debugger\"); } return bDetect; } デバッガーのウィンドウキャプションを見つけてプログラムを終了させる。\nIsDebuggerPresent MSDNに記載されていてkernel32.dllから提供されている。\nif (IsDebuggerPresent()) { exit(1); } アセンブリになると下記のようになる\nmov eax, dword ptf fs:[18] mov eax, dword ptr ds:[eax+30] movzx eax, byte ptr ds:[eax+2] retn fs:[18] はTEBを指す。(Thread Environment Block)\nTEBをEAXに入れたがそこから30番地離れたアドレスを再びEAXに入力するコードだ。\nTEBから0x30離れたところにはPEB(Process Environment Block) がある。\nEAXにはPEBが入っていて、そこから+2移動したアドレスから1バイト持ってきていると解釈できる。\nPEBの構造体は下記の通り。\ntypedef struct _PEB { BYTE Reserved1[2]; BYTE BeingDebugged; BYTE Reserved2[1]; PVOID Reserved3[2]; PPEB_LDR_DATA Ldr; PRTL_USER_PROCESS_PARAMETERS ProcessParameters; PVOID Reserved4[3]; PVOID AtlThunkSListPtr; PVOID Reserved5; ULONG Reserved6; PVOID Reserved7; ULONG Reserved8; ULONG AtlThunkSListPtr32; PVOID Reserved9[45]; BYTE Reserved10[96]; PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine; BYTE Reserved11[128]; PVOID Reserved12[1]; ULONG SessionId; } PEB, *PPEB; BeingDebugged という名前の箇所の値を入れている。\nここにtrueが入っているとデバッグ中であり、falseが入っているとデバッグ中ではないことを表現する。\nNtQueryInformationProcess ntdll.dllにエクスポートされている NtQueryInformationProcess() というネイティブAPIを利用した方法を書く。\nデバッグポートをチェックする方法と呼ばれる。\nデバッグポートはカーネルで管理する EPROCESS 構造体の DebugPort フラグで有効にされ、 NtQueryInformationProcess はその値を取得する。\nNtQueryInformationProcess の2番目の引数として7を渡すとデバッグポートがチェックされる。\nCheckRemoteDebuggerPresent という関数でも提供され kernel32.dll にエクスポートされている。\nチェックを実装するコードも簡単である。\nBOOL bDebugged = FALSE; CheckRemoteDebuggerPresent(GetCurrentProcess(), \u0026bDebugged); if (bDebugged) exit(1); 内部的にはNtQueryInformationProcessを使用する。\nDebug Object Handle NtQueryInformationProcess() はアンチでバッグに関連して多くの機能を提供する。\nデバッグポートに加えてデバッグ時に使用されるDebug Object Handle というハンドルを取得してくれる。\n2番目の引数に0x1Eという値を入れると、3番目の引数にハンドルのポインターを渡してくれる。\nこのハンドルの有効性を確認するとデバッグ中かどうか確認できる。\nNtQUeryObject 前述したDebug Object Handle を検索する方法と同様に NtQueryObject というネイティブAPIを呼び出す方法もある。\nこれはシステムで現在デバッガーが動作中である場合にどんな変化があるか調べる方法である。\nデバッグ中はカーネル内にDebugObject型のオブジェクトが生成されるが NtQueryObject() を呼び出すとすべてのオブジェクトの型の情報が手に入るのでここでDebugObjectのオブジェクトも取得して確認する。\nNtQueryObject では2番目の引数にどのようなオブジェクトを取得するか指定する。ここではすべてのオブジェクトの情報を取得する必要があるので ObjectAllInformation である3を指定する。\nそして取得したオブジェクトの中から DebugObject というオブジェクトを文字列比較で探し、その文字列が存在したらシステムには現在でバッグオブジェクトが存在し、デバッグ中であることがわかる。\nNoDebugInherit NtQueryInformationProcess() にはもう一つのデバッグチェック機能がある。\n0x1fを2番目の引数に渡すとProcessDebugFlagsとなり、デバッグ中であることを判断してくれる。\n2番目の引数に0x1fを2番目の引数に渡すと3番目の引数にNoDebugInheritが渡される。\nNtSetInformationThread スレッドをデバッガーから隠す方法。\n使用する引数の名前も ThreadHideFromDebugger でわかりやすい。名前にHideという名前が入っているが完全にスレッドが隠れるわけではない。\nデバッガーがスレッドを呼び出す際に制御を譲ってくれないだけである。\nNTSYSAPI NTSTATUS ZwSetInformationThread( [in] HANDLE ThreadHandle, [in] THREADINFOCLASS ThreadInformationClass, [in] PVOID ThreadInformation, [in] ULONG ThreadInformationLength ); この関数の本来の役割はスレッドの優先順位を設定することだが、Windows 2000からは純粋にアンチデバッグのためにこの関数をアップグレードしたと言われる。\n重要なのは THREAD_INFORMATION_CLASS の enum 値である。\n0x11の値にThreadHideFromDebuggerという名前がある。\nこれを引数として渡すと生成したスレッドをデバッガーから隠すことができる。\nNumeric Value Symbolic Name Versions 0x00 ThreadBasicInformation all 0x01 ThreadTimes all 0x02 ThreadPriority all 0x03 ThreadBasePriority all 0x04 ThreadAffinityMask all 0x05 ThreadImpersonationToken all 0x06 ThreadDescriptorTableEntry all 0x07 ThreadEnableAlignmentFaultFixup all 0x08 ThreadEventPair 3.10 to 4.0 ThreadEventPair_Reusable 5.0 and higher 0x09 ThreadQuerySetWin32StartAddress all 0x0A unknown 3.10 only 0x0B (3.10);0x0A ThreadZeroTlsCell all 0x0B ThreadPerformanceCount 3.51 and higher 0x0C ThreadAmILastThread 3.51 and higher 0x0D ThreadIdealProcessor 4.0 and higher 0x0E ThreadPriorityBoost 4.0 and higher 0x0F ThreadSetTlsArrayAddress 4.0 and higher 0x10 ThreadIsIoPending 5.0 and higher 0x11 ThreadHideFromDebugger 5.0 and higher 0x12 ThreadBreakOnTermination 5.2 and higher 0x13 ThreadSwitchLegacyState 5.2 from Windows Server 2003 SP1, and higher 0x14 ThreadIsTerminated 5.2 from Windows Server 2003 SP1, and higher 0x15 ThreadLastSystemCall 6.0 and higher 0x16 ThreadIoPriority 6.0 and higher 0x17 ThreadCycleTime 6.0 and higher 0x18 ThreadPagePriority 6.0 and higher 0x19 ThreadActualBasePriority 6.0 and higher 0x1A ThreadTebInformation 6.0 and higher 0x1B ThreadCSwitchMon 6.0 and higher 0x1C ThreadCSwitchPmu 6.1 and higher 0x1D ThreadWow64Context 6.1 and higher 0x1E ThreadGroupInformation 6.1 and higher 0x1F ThreadUmsInformation 6.1 and higher 0x20 ThreadCounterProfiling 6.1 and higher 0x21 ThreadIdealProcessorEx 6.1 and higher 0x22 ThreadCpuAccountingInformation 6.2 and higher 0x23 ThreadSuspendCount 6.3 and higher 0x24 ThreadHeterogeneousCpuPolicy 10.0 and higher 0x25 ThreadContainerId 10.0 and higher 0x26 ThreadNameInformation 10.0 and higher 0x27 ThreadSelectedCpuSets 10.0 and higher 0x28 ThreadSystemThreadInformation 10.0 and higher 0x29 ThreadActualGroupAffinity 10.0 and higher MaxThreadInfoClass all int 3の利用 デバッガーは int 3 や int 1 命令を通過するとき基本的に例外処理をしない。\nしたがってデバッガーでは __exceptコードを実行しないためデバッグ中かそれで判断できる。\nvoid Int3SingStepDetection() { DWORD dwDebugger = 1; __try { __asm { __emit 0xcc } } __except(EXCEPTION_EXECUTE_HANDLER) { dwDebugger = 0; } if (dwDebugger) exit(1); } デバッガを使用中でなければこのコードは__try 野中を実行してint 3 を呼び出す。\nint 3 が呼ばれると例外になり __exceptが実行され dwDebuggerが0になる。\nしかしデバッガーの使用中だと例外が発生した際に __except内は実行されず例外処理をデバッガーに引き渡すので dwDebuggerが0にならない。\nそのためデバッガーを使用していることがわかる。\n__emit 0xcc は int 3 を記録したコードである。\nこの方法はシングルステップで進むときにのみ検出され int 3 を強制的に呼び出すコードの部分を jmp に飛ばしてしまうと検出されないという欠点がある。\nまた OllyDBGのオプションの追加で簡単に回避できたりする。\nパッカーが自身のコードを複合するために使用したりする。\nSetUnhandledExceptionFilter 同様の技術で SetUnhandeledExceptionFilter を利用した方法もある。\nWindows XP以降のシステムでは例外処理についてSEH(Structured Exception Handling)を使用せずにベクトル化例外処理であるVEH(Vector Exception Handling)を使用する。\nしたがってプログラミングをするとき次のような構造となる。\nvoid main() { SetUnhandledExceptionFilter(OnMyException); } LONG WINAPI OnMyException(PEXCEPTION_POINTERS pExcepPointers){ //例外処理 } この技術では例外が起きるとプログラマが作成したOnMyException()という例外処理関数が呼び出されそのハンドラの中で例外を処理する。\n今度はEIPを直接コントロールしながら例外が発生したときとそうでないときのコードの流れを変更する。\nvoid UnHandleException() { SetUnHandleExceptionFilter(UnhandledExceptionFilter); __asm{xor eax, eax} __asm{div eax} } このようにSetUnhandledExceptionFilter APIを利用して例外が発生したときにUnhandledExcepFilterが呼び出されるようにした。そして次の行ですぐにEAXを0いし、それを割り算するコードを続け例外が発生するコードを作成した。\n例外が起きると次のコードが実行される。\nLONG WINAPI UnhandledExcepFilter(PEXCEPTION_POINTERS pExcepPointers){ SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)pExcepPointers-\u003eContextRecord-\u003eEax); pExcepPointers-\u003eContextRecord-\u003eEip += 2; return EXCEPTION_CONTINUE_EXECUTION; } EXCEPTION_POINTERS構造体を使用することができるのでContextの値をコントロールすることが可能である。\nEIPを取得して現在のEIPの位置を2だけ増加させてから次の処理を実行するように記述した。\nEIPは現在事項されているコードのアドレスが入っているレジスタである。\nそれを2だけ増やしたということはポインターを2だけ増加させたことになる。\n例外が発生している状態ではEIPは例外が発生した場所になる。\nするとポインターが移動しretnに飛ばされる。\nつまり例外が発生したコードをスキップしその次の正常なコードに移動させるコードとなる。\n最初の__tryを用いた手法よりも若干高度になった。\nあとは__tryを用いたときと同様に書けばデバッグを回避することができる。\n0xCCそのものを検出する int 3の値である0xCCについて深堀する。\nユーザレベルのデバッガを使用するとブレークポイントを必ず設定することになる。\nブレークポイントは割り込み3番でオペコードは0xCCになる。\nこのためデバッグ中の場合は必ず現在のEIPに0xccが入るのでそれをチェックする方法もある。\n0xCCが入るとコード領域の部分のハッシュ値が変更されるのでハッシュ値を検査する方法でもデバッグ中か判断できる。\nPEBを利用した方法 プロセス内部のフラグ情報を利用して現在のプログラムがデバッグ中華判断する方法。\nPEBにはプロセスオブジェクトのいくつかの情報が入っている。\n代表的なものとしてイメージベースアドレス、ヒープマネージャ、DLL関連の情報などがはいっている。\nデバッグ関連情報もこの構造体を通じて確認可能。\nPEB構造体にアクセスするといくつかのメンバー変数の値を用いて現在のプログラムがデバッグ中かどうか判断できる。\nPEBはユーザプロセス空間に入っているがFSレジスタを利用して簡単に求めることができる。\nデバッグの検出方法はBeingDebuggedメンバー変数を取得する方法である。\nmov eax, fs:[30h] mov eax, byte[eax+2] test eax, eax jne @DebuggerDetected fs:[30h] がPEBでありその0x2番目のメンバがBeingDebuggedである。\nIsDebuggerPresentと同じ内容。\n次はPEBの0x68番目のメンバ変数である NtGlobalFlag を利用する方法である。\nプロセスが生成されたあと、システムでは各プロセスに対していくつかフラグを設定するがNtGlobalFlagの場合にはデバッグ中でない場合は0、デバッグ中の場合は0x70という値が設定される。\nmov eax, fs:[30h] mov eax, [eax+68h] and eax, 0x70 test eax, eax jne @DebuggerDetected 上記コードで検知できる。\n3番目はヒープフラグを使用した方法である。\n仕組みはBeingDebuggedやNtGlobalFlagと同様である。\nPEBにアクセスしたあとProcessHeapに対応する構造体のアドレスを取得し、その値を比較してデバッグ中であるか確認する。\nProcessHeapはHANDLE型なのでHEAP構造体にもう一度アクセスしなければならない。\nプロセスのヒープが生成されるとき0xcと0x10の位置にFlags, ForceFlagsのメンバがあることがわかる。また、それぞれ2,0の値が入る。\nしかしデバッグ中はそれぞれ0x50000062と0x40000060に変わる。\nこの規則性を利用して確認すればデバッグ中か確認できる。\nFlagsの場合\nmov eax, fs:[30h] mov eax, [eax+18h]; process heap cmp dword [eax+0x0c], 2 jne .debugger_found ForceFlagsの場合\nmov eax, [eax+10h]; force flags test eax, eax jne @DebuggerDetected プロセスのチェック プロセスを列挙する。\nProcess32First/Process32Nextを用いることでデバッガのプロセスを見つけることができる。\nバージョンチェック 現在実行中のプロセスのバージョン情報を取得しそれがデバッガなどの値と一致すればデバッグ中であると判断できる。\nOllyDBGなどではアンチでバッグを避けるためにファイルをパッキングしたりウィンドウの文字列を変更したり実行ファイル名を変更することはあるがバージョン情報を書き換えることは少ない。\nバージョン情報は VerQueryValue というAPIを呼び出すことでバージョンを調べることができる。\n親プロセスのチェック プロセスを実行させた主体がどのプロセス化チェックする方法。\nシステムで実行されるプロセスはそのプロセスを実行させた親プロセスが存在する。\nたとえばエクスプローラからメモ帳を起動すると子プロセスのnotepad.exeの親プロセスはexplorer.exeになる。\nToolHelp32 ライブラリを利用すると PROCESSENTRY32 という構造体の中に th32ParentProcessID という名前の変数がある。\nこの変数の中に親プロセスのPIDが含まれているので親プロセスのPIDが explorer.exeやcmd.exe出ない場合はデバッグ中だと判断できる。\nSeDebugPrivilege 権限チェック プロセスのデバッグ中はSeDebugPrivilege権限を使用することになる。\nしたがってSeDebugPrivilege権限を得た場合、システムプロセスの一つである csrss.exe のプロセスのハンドルが取得できるのでこれを取得できるかどうかに着目した方法をアンチでバッグに利用できる。\ncsrss.exeのプロセスをOpenProcess()で開いてハンドルが取得できたら現在のプロセスはSeDebugPrivilege権限を得ていると仮定し、デバッガーによって実行されていると判断できる。\nTool Help LibraryでProcess32Nextでループを回って取得しても良いが、ntdll.dllにはCsrGetProcessIdというAPIがある。この関数を用いるとcsrss.exeのPIDを取得する。\nこれをOpenPorcess関数の引数として私PROCESS_ALL_ACCESS権限でプロセスハンドルを取得できればデバッグされていると判断できる。\nWINDBGの検出 bool WindbgClassNameDetect() { HANDLE hWinDbg = ::FindWindow(\"WinDbgFrameClass\", NULL); if (hWinDbg) return true; return false; } WinDBGはWinDbgFrameClassというクラス名を持っているのでそのクラス名でハンドルを見つけることで検出可能である。\nキーボード入力のブロック リバースエンジニアリング、デバッグ時にキーボードやマウスの操作をできなくする。\nBlockInput() というWin32 APIがその役割を果たす。引数にTRUEを渡すとキーボードやマウス入力がブロックされ、FALSEを渡して再び呼び出すと入力が可能になる。\nvoid BlockAllControl() { typedef BOOL (__stdcall *TBLOCKINPUT)(BOOL); TBLOCKINPUT fnBlockInput = (TBLOCKINPUT)GetProcAddress(GetModuleHandle(\"user32.dll\"), \"BlockInput\"); fnBlockInput(TRUE); sleep(5000); fnBlockInput(FALSE); } 5秒間マウスとキーボードの動きを止めるサンプル。\n時間差攻撃 DWORD TimeCheck(int a, int b){ DWORD dwStart = GetTickCount(); int c = a ^ 0x369; int d = c + b * 0xdead; int e = d / a; DWORD dwEnd = GetTickCount(); if (dwEnd - dwStart \u003e 1000) return e = 0; return e; } リバースエンジニアリングしているときは1秒以上実行に時間がかかるはずなのでデバッグ中であると判断できる。\nrdtscを利用した方法はWinAPIを使用しないので比較的強力である。\nPREFIX REP による例外処理 例外ハンドラに送るものと似たような方法。\nインラインアセンブラでprefix値を追加するとデバッグ中とそうでないときで実行のされ方が異なることを利用した方法。\nbool IsDbgPresentPrefixCheck() { __try { __asm __emit 0xF3 __asm __emit 0x64 __asm __emit 0xF1 } __except(EXCEPTION_EXECUTE_HANDLER) { // debugger not found return false; } return true; } __asm 似続けて __emit を入力してからオペコードを入れると0xF3という値がバイナリにそのまま埋め込まれる。すなわちこのコードのようにアセンブラコードを3業入れるとバイナリには次のように記録される。\nF3 64 // prefix rep F1 // int 1 prefix rep命令は本来はリピートの用途で使用されるが、この命令を上記のように作成しておいてしうぐにint 1を呼び出すとデバッグ中には正常に動作しない。\n通常の状況であれば次のステップに進みint 1で例外ハンドラに移るのだが、現在のプログラムがデバッグ中である場合はハンドラに進まず return true;に進むのでデバッグ中だと判断することができる。\nコードがこのように動く理由は pop ss が実行されると CPU はスタックが壊れないように割り込み発生を防ぐからである。\nこのためシングルステップトレースでフラグを設定しても無視されて結局デバッガでは実行されてしまい検出できなくなる。\nアセンブラコードの影響で少し複雑に見えるが例外ハンドラを利用した分岐の延長だと思えば簡単だ。\nAPI フックを利用したデバッグ検出 APIフックを利用してアンチでバッグ機能を実現することができる。\nデバッガをプイロセスにあタッチする際、内部的にDebugActiveProcess() というAPIを利用する。\nこのAPIを無力化するとアタッチ自体が不可能になるためデバッグとリバーシングが困難になる。\nBOOL DebugActiveProcess(DWORD dwProcessId) BOOL 変数であるためこのAPIをブロックするにはFALSEを返すだけで良い。\n戻りちはEAXに入るため、EAXに値を入れてリターンさせるコードをDebugActiveProcess()のエントリポイントに入力しよう。\nDbgUiRemoteBreakinやOpenProcess, ReadProcessMemory, WriteProcessMemoryを無力化してデバッガでプロセスの情報を得られないようにすることができる。\nDbgUiRemoteBreakinカーネルではKiMoveApcState, KeStackAttachProcessなどのAPIを制御してプロセスのあタッチをより低いレベルで管理することができる。\nリモートでバッグの検出 BOOL IsRemoteDebugger() { BOOL bDetection = FALSE; KdRefreshDebuggerNotPresent(); if (KD_DEBUGGER_NOT_PRESENT == FALSE) { bDetection = TRUE; DbgPrint(\"Debugger attached\"); } else { DbgPrint(\"Debugger Not Attached\"); } return bDetection; } ","wordCount":"854","inLanguage":"en","image":"https://famasoon.github.io/static/famasoon.jpg","datePublished":"2023-10-12T00:00:00Z","dateModified":"2023-10-12T00:00:00Z","author":{"@type":"Person","name":"FAMASoon"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://famasoon.github.io/posts/antidebug/"},"publisher":{"@type":"Organization","name":"x64.moe","logo":{"@type":"ImageObject","url":"https://famasoon.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://famasoon.github.io/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://famasoon.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://famasoon.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://famasoon.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://famasoon.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Anti-debug introduction</h1><div class=post-meta><span title='2023-10-12 00:00:00 +0000 UTC'>October 12, 2023</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;854 words&nbsp;·&nbsp;FAMASoon&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/antidebug.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h1 id=anti-debug>Anti-debug<a hidden class=anchor aria-hidden=true href=#anti-debug>#</a></h1><p>アンチデバッグのやり方はたくさんあるが、その中でもよく使われるものを紹介する。</p><p>網羅的に把握したい場合は下記リンクを参照すると良い。</p><p><a href=https://unprotect.it/category/anti-debugging/>https://unprotect.it/category/anti-debugging/</a></p><h2 id=古典的なアンチデバッグ>古典的なアンチデバッグ<a hidden class=anchor aria-hidden=true href=#古典的なアンチデバッグ>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>FindDebugger</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=n>bDetect</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>HWND</span> <span class=n>hDebugger</span> <span class=o>=</span> <span class=o>::</span><span class=n>FindWindow</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=s>&#34;OllyDBG&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>hDebugger</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>bDetect</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>AfxMessageBox</span><span class=p>(</span><span class=s>&#34;Can not use debugger&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>bDetect</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>デバッガーのウィンドウキャプションを見つけてプログラムを終了させる。</p><h2 id=isdebuggerpresent>IsDebuggerPresent<a hidden class=anchor aria-hidden=true href=#isdebuggerpresent>#</a></h2><p>MSDNに記載されていてkernel32.dllから提供されている。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>IsDebuggerPresent</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>アセンブリになると下記のようになる</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>mov</span> <span class=n>eax</span><span class=p>,</span> <span class=n>dword</span> <span class=n>ptf</span> <span class=nl>fs</span><span class=p>:[</span><span class=mi>18</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>mov</span> <span class=n>eax</span><span class=p>,</span> <span class=n>dword</span> <span class=n>ptr</span> <span class=nl>ds</span><span class=p>:[</span><span class=n>eax</span><span class=o>+</span><span class=mi>30</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>movzx</span> <span class=n>eax</span><span class=p>,</span> <span class=n>byte</span> <span class=n>ptr</span> <span class=nl>ds</span><span class=p>:[</span><span class=n>eax</span><span class=o>+</span><span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>retn</span>
</span></span></code></pre></div><p>fs:[18] はTEBを指す。(Thread Environment Block)</p><p>TEBをEAXに入れたがそこから30番地離れたアドレスを再びEAXに入力するコードだ。</p><p>TEBから0x30離れたところにはPEB(Process Environment Block) がある。</p><p>EAXにはPEBが入っていて、そこから+2移動したアドレスから1バイト持ってきていると解釈できる。</p><p>PEBの構造体は下記の通り。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>_PEB</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>BYTE</span>                          <span class=n>Reserved1</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>BYTE</span>                          <span class=n>BeingDebugged</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>BYTE</span>                          <span class=n>Reserved2</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>PVOID</span>                         <span class=n>Reserved3</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>PPEB_LDR_DATA</span>                 <span class=n>Ldr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>PRTL_USER_PROCESS_PARAMETERS</span>  <span class=n>ProcessParameters</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>PVOID</span>                         <span class=n>Reserved4</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>PVOID</span>                         <span class=n>AtlThunkSListPtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>PVOID</span>                         <span class=n>Reserved5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>ULONG</span>                         <span class=n>Reserved6</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>PVOID</span>                         <span class=n>Reserved7</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>ULONG</span>                         <span class=n>Reserved8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>ULONG</span>                         <span class=n>AtlThunkSListPtr32</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>PVOID</span>                         <span class=n>Reserved9</span><span class=p>[</span><span class=mi>45</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>BYTE</span>                          <span class=n>Reserved10</span><span class=p>[</span><span class=mi>96</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>PPS_POST_PROCESS_INIT_ROUTINE</span> <span class=n>PostProcessInitRoutine</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>BYTE</span>                          <span class=n>Reserved11</span><span class=p>[</span><span class=mi>128</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>PVOID</span>                         <span class=n>Reserved12</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>ULONG</span>                         <span class=n>SessionId</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>PEB</span><span class=p>,</span> <span class=o>*</span><span class=n>PPEB</span><span class=p>;</span>
</span></span></code></pre></div><p><code>BeingDebugged</code> という名前の箇所の値を入れている。</p><p>ここにtrueが入っているとデバッグ中であり、falseが入っているとデバッグ中ではないことを表現する。</p><h2 id=ntqueryinformationprocess>NtQueryInformationProcess<a hidden class=anchor aria-hidden=true href=#ntqueryinformationprocess>#</a></h2><p>ntdll.dllにエクスポートされている <code>NtQueryInformationProcess()</code> というネイティブAPIを利用した方法を書く。</p><p>デバッグポートをチェックする方法と呼ばれる。</p><p>デバッグポートはカーネルで管理する <code>EPROCESS</code> 構造体の <code>DebugPort</code> フラグで有効にされ、 <code>NtQueryInformationProcess</code> はその値を取得する。</p><p><code>NtQueryInformationProcess</code> の2番目の引数として7を渡すとデバッグポートがチェックされる。</p><p><code>CheckRemoteDebuggerPresent</code> という関数でも提供され <code>kernel32.dll</code> にエクスポートされている。</p><p>チェックを実装するコードも簡単である。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>BOOL</span> <span class=n>bDebugged</span> <span class=o>=</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>CheckRemoteDebuggerPresent</span><span class=p>(</span><span class=n>GetCurrentProcess</span><span class=p>(),</span> <span class=o>&amp;</span><span class=n>bDebugged</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>bDebugged</span><span class=p>)</span> <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span></code></pre></div><p>内部的にはNtQueryInformationProcessを使用する。</p><h2 id=debug-object-handle>Debug Object Handle<a hidden class=anchor aria-hidden=true href=#debug-object-handle>#</a></h2><p><code>NtQueryInformationProcess()</code> はアンチでバッグに関連して多くの機能を提供する。</p><p>デバッグポートに加えてデバッグ時に使用されるDebug Object Handle というハンドルを取得してくれる。</p><p>2番目の引数に0x1Eという値を入れると、3番目の引数にハンドルのポインターを渡してくれる。</p><p>このハンドルの有効性を確認するとデバッグ中かどうか確認できる。</p><h2 id=ntqueryobject>NtQUeryObject<a hidden class=anchor aria-hidden=true href=#ntqueryobject>#</a></h2><p>前述したDebug Object Handle を検索する方法と同様に <code>NtQueryObject</code> というネイティブAPIを呼び出す方法もある。</p><p>これはシステムで現在デバッガーが動作中である場合にどんな変化があるか調べる方法である。</p><p>デバッグ中はカーネル内にDebugObject型のオブジェクトが生成されるが <code>NtQueryObject()</code> を呼び出すとすべてのオブジェクトの型の情報が手に入るのでここでDebugObjectのオブジェクトも取得して確認する。</p><p><code>NtQueryObject</code> では2番目の引数にどのようなオブジェクトを取得するか指定する。ここではすべてのオブジェクトの情報を取得する必要があるので <code>ObjectAllInformation</code> である3を指定する。</p><p>そして取得したオブジェクトの中から <code>DebugObject</code> というオブジェクトを文字列比較で探し、その文字列が存在したらシステムには現在でバッグオブジェクトが存在し、デバッグ中であることがわかる。</p><h2 id=nodebuginherit>NoDebugInherit<a hidden class=anchor aria-hidden=true href=#nodebuginherit>#</a></h2><p><code>NtQueryInformationProcess()</code> にはもう一つのデバッグチェック機能がある。</p><p>0x1fを2番目の引数に渡すとProcessDebugFlagsとなり、デバッグ中であることを判断してくれる。</p><p>2番目の引数に0x1fを2番目の引数に渡すと3番目の引数にNoDebugInheritが渡される。</p><h2 id=ntsetinformationthread>NtSetInformationThread<a hidden class=anchor aria-hidden=true href=#ntsetinformationthread>#</a></h2><p>スレッドをデバッガーから隠す方法。</p><p>使用する引数の名前も <code>ThreadHideFromDebugger</code> でわかりやすい。名前にHideという名前が入っているが完全にスレッドが隠れるわけではない。</p><p>デバッガーがスレッドを呼び出す際に制御を譲ってくれないだけである。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>NTSYSAPI</span> <span class=n>NTSTATUS</span> <span class=nf>ZwSetInformationThread</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>in</span><span class=p>]</span> <span class=n>HANDLE</span>          <span class=n>ThreadHandle</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>in</span><span class=p>]</span> <span class=n>THREADINFOCLASS</span> <span class=n>ThreadInformationClass</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>in</span><span class=p>]</span> <span class=n>PVOID</span>           <span class=n>ThreadInformation</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>in</span><span class=p>]</span> <span class=n>ULONG</span>           <span class=n>ThreadInformationLength</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><p>この関数の本来の役割はスレッドの優先順位を設定することだが、Windows 2000からは純粋にアンチデバッグのためにこの関数をアップグレードしたと言われる。</p><p>重要なのは <code>THREAD_INFORMATION_CLASS</code> の enum 値である。</p><p>0x11の値にThreadHideFromDebuggerという名前がある。</p><p>これを引数として渡すと生成したスレッドをデバッガーから隠すことができる。</p><table><thead><tr><th style=text-align:left>Numeric Value</th><th style=text-align:left>Symbolic Name</th><th style=text-align:left>Versions</th></tr></thead><tbody><tr><td style=text-align:left>0x00</td><td style=text-align:left>ThreadBasicInformation</td><td style=text-align:left>all</td></tr><tr><td style=text-align:left>0x01</td><td style=text-align:left>ThreadTimes</td><td style=text-align:left>all</td></tr><tr><td style=text-align:left>0x02</td><td style=text-align:left>ThreadPriority</td><td style=text-align:left>all</td></tr><tr><td style=text-align:left>0x03</td><td style=text-align:left>ThreadBasePriority</td><td style=text-align:left>all</td></tr><tr><td style=text-align:left>0x04</td><td style=text-align:left>ThreadAffinityMask</td><td style=text-align:left>all</td></tr><tr><td style=text-align:left>0x05</td><td style=text-align:left>ThreadImpersonationToken</td><td style=text-align:left>all</td></tr><tr><td style=text-align:left>0x06</td><td style=text-align:left>ThreadDescriptorTableEntry</td><td style=text-align:left>all</td></tr><tr><td style=text-align:left>0x07</td><td style=text-align:left>ThreadEnableAlignmentFaultFixup</td><td style=text-align:left>all</td></tr><tr><td style=text-align:left>0x08</td><td style=text-align:left>ThreadEventPair</td><td style=text-align:left>3.10 to 4.0</td></tr><tr><td style=text-align:left></td><td style=text-align:left>ThreadEventPair_Reusable</td><td style=text-align:left>5.0 and higher</td></tr><tr><td style=text-align:left>0x09</td><td style=text-align:left>ThreadQuerySetWin32StartAddress</td><td style=text-align:left>all</td></tr><tr><td style=text-align:left>0x0A</td><td style=text-align:left>unknown</td><td style=text-align:left>3.10 only</td></tr><tr><td style=text-align:left>0x0B (3.10);0x0A</td><td style=text-align:left>ThreadZeroTlsCell</td><td style=text-align:left>all</td></tr><tr><td style=text-align:left>0x0B</td><td style=text-align:left>ThreadPerformanceCount</td><td style=text-align:left>3.51 and higher</td></tr><tr><td style=text-align:left>0x0C</td><td style=text-align:left>ThreadAmILastThread</td><td style=text-align:left>3.51 and higher</td></tr><tr><td style=text-align:left>0x0D</td><td style=text-align:left>ThreadIdealProcessor</td><td style=text-align:left>4.0 and higher</td></tr><tr><td style=text-align:left>0x0E</td><td style=text-align:left>ThreadPriorityBoost</td><td style=text-align:left>4.0 and higher</td></tr><tr><td style=text-align:left>0x0F</td><td style=text-align:left>ThreadSetTlsArrayAddress</td><td style=text-align:left>4.0 and higher</td></tr><tr><td style=text-align:left>0x10</td><td style=text-align:left>ThreadIsIoPending</td><td style=text-align:left>5.0 and higher</td></tr><tr><td style=text-align:left>0x11</td><td style=text-align:left>ThreadHideFromDebugger</td><td style=text-align:left>5.0 and higher</td></tr><tr><td style=text-align:left>0x12</td><td style=text-align:left>ThreadBreakOnTermination</td><td style=text-align:left>5.2 and higher</td></tr><tr><td style=text-align:left>0x13</td><td style=text-align:left>ThreadSwitchLegacyState</td><td style=text-align:left>5.2 from Windows Server 2003 SP1, and higher</td></tr><tr><td style=text-align:left>0x14</td><td style=text-align:left>ThreadIsTerminated</td><td style=text-align:left>5.2 from Windows Server 2003 SP1, and higher</td></tr><tr><td style=text-align:left>0x15</td><td style=text-align:left>ThreadLastSystemCall</td><td style=text-align:left>6.0 and higher</td></tr><tr><td style=text-align:left>0x16</td><td style=text-align:left>ThreadIoPriority</td><td style=text-align:left>6.0 and higher</td></tr><tr><td style=text-align:left>0x17</td><td style=text-align:left>ThreadCycleTime</td><td style=text-align:left>6.0 and higher</td></tr><tr><td style=text-align:left>0x18</td><td style=text-align:left>ThreadPagePriority</td><td style=text-align:left>6.0 and higher</td></tr><tr><td style=text-align:left>0x19</td><td style=text-align:left>ThreadActualBasePriority</td><td style=text-align:left>6.0 and higher</td></tr><tr><td style=text-align:left>0x1A</td><td style=text-align:left>ThreadTebInformation</td><td style=text-align:left>6.0 and higher</td></tr><tr><td style=text-align:left>0x1B</td><td style=text-align:left>ThreadCSwitchMon</td><td style=text-align:left>6.0 and higher</td></tr><tr><td style=text-align:left>0x1C</td><td style=text-align:left>ThreadCSwitchPmu</td><td style=text-align:left>6.1 and higher</td></tr><tr><td style=text-align:left>0x1D</td><td style=text-align:left>ThreadWow64Context</td><td style=text-align:left>6.1 and higher</td></tr><tr><td style=text-align:left>0x1E</td><td style=text-align:left>ThreadGroupInformation</td><td style=text-align:left>6.1 and higher</td></tr><tr><td style=text-align:left>0x1F</td><td style=text-align:left>ThreadUmsInformation</td><td style=text-align:left>6.1 and higher</td></tr><tr><td style=text-align:left>0x20</td><td style=text-align:left>ThreadCounterProfiling</td><td style=text-align:left>6.1 and higher</td></tr><tr><td style=text-align:left>0x21</td><td style=text-align:left>ThreadIdealProcessorEx</td><td style=text-align:left>6.1 and higher</td></tr><tr><td style=text-align:left>0x22</td><td style=text-align:left>ThreadCpuAccountingInformation</td><td style=text-align:left>6.2 and higher</td></tr><tr><td style=text-align:left>0x23</td><td style=text-align:left>ThreadSuspendCount</td><td style=text-align:left>6.3 and higher</td></tr><tr><td style=text-align:left>0x24</td><td style=text-align:left>ThreadHeterogeneousCpuPolicy</td><td style=text-align:left>10.0 and higher</td></tr><tr><td style=text-align:left>0x25</td><td style=text-align:left>ThreadContainerId</td><td style=text-align:left>10.0 and higher</td></tr><tr><td style=text-align:left>0x26</td><td style=text-align:left>ThreadNameInformation</td><td style=text-align:left>10.0 and higher</td></tr><tr><td style=text-align:left>0x27</td><td style=text-align:left>ThreadSelectedCpuSets</td><td style=text-align:left>10.0 and higher</td></tr><tr><td style=text-align:left>0x28</td><td style=text-align:left>ThreadSystemThreadInformation</td><td style=text-align:left>10.0 and higher</td></tr><tr><td style=text-align:left>0x29</td><td style=text-align:left>ThreadActualGroupAffinity</td><td style=text-align:left>10.0 and higher</td></tr><tr><td style=text-align:left></td><td style=text-align:left>MaxThreadInfoClass</td><td style=text-align:left>all</td></tr></tbody></table><h2 id=int-3の利用>int 3の利用<a hidden class=anchor aria-hidden=true href=#int-3の利用>#</a></h2><p>デバッガーは <code>int 3</code> や <code>int 1</code> 命令を通過するとき基本的に例外処理をしない。</p><p>したがってデバッガーでは <code>__except</code>コードを実行しないためデバッグ中かそれで判断できる。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Int3SingStepDetection</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span> <span class=n>dwDebugger</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kr>__try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>__asm</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>__emit</span> <span class=mh>0xcc</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kr>__except</span><span class=p>(</span><span class=n>EXCEPTION_EXECUTE_HANDLER</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>dwDebugger</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>dwDebugger</span><span class=p>)</span> <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>デバッガを使用中でなければこのコードは__try 野中を実行してint 3 を呼び出す。</p><p>int 3 が呼ばれると例外になり __exceptが実行され dwDebuggerが0になる。</p><p>しかしデバッガーの使用中だと例外が発生した際に __except内は実行されず例外処理をデバッガーに引き渡すので dwDebuggerが0にならない。</p><p>そのためデバッガーを使用していることがわかる。</p><p><code>__emit 0xcc</code> は <code>int 3</code> を記録したコードである。</p><p>この方法はシングルステップで進むときにのみ検出され <code>int 3</code> を強制的に呼び出すコードの部分を jmp に飛ばしてしまうと検出されないという欠点がある。</p><p>また OllyDBGのオプションの追加で簡単に回避できたりする。</p><p>パッカーが自身のコードを複合するために使用したりする。</p><h2 id=setunhandledexceptionfilter>SetUnhandledExceptionFilter<a hidden class=anchor aria-hidden=true href=#setunhandledexceptionfilter>#</a></h2><p>同様の技術で <code>SetUnhandeledExceptionFilter</code> を利用した方法もある。</p><p>Windows XP以降のシステムでは例外処理についてSEH(Structured Exception Handling)を使用せずにベクトル化例外処理であるVEH(Vector Exception Handling)を使用する。</p><p>したがってプログラミングをするとき次のような構造となる。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>SetUnhandledExceptionFilter</span><span class=p>(</span><span class=n>OnMyException</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>LONG</span> <span class=n>WINAPI</span> <span class=nf>OnMyException</span><span class=p>(</span><span class=n>PEXCEPTION_POINTERS</span> <span class=n>pExcepPointers</span><span class=p>){</span>
</span></span><span class=line><span class=cl> <span class=c1>//例外処理
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>この技術では例外が起きるとプログラマが作成したOnMyException()という例外処理関数が呼び出されそのハンドラの中で例外を処理する。</p><p>今度はEIPを直接コントロールしながら例外が発生したときとそうでないときのコードの流れを変更する。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>UnHandleException</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>SetUnHandleExceptionFilter</span><span class=p>(</span><span class=n>UnhandledExceptionFilter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kr>__asm</span><span class=p>{</span><span class=n>xor</span> <span class=n>eax</span><span class=p>,</span> <span class=n>eax</span><span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kr>__asm</span><span class=p>{</span><span class=n>div</span> <span class=n>eax</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>このようにSetUnhandledExceptionFilter APIを利用して例外が発生したときにUnhandledExcepFilterが呼び出されるようにした。そして次の行ですぐにEAXを0いし、それを割り算するコードを続け例外が発生するコードを作成した。</p><p>例外が起きると次のコードが実行される。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>LONG</span> <span class=n>WINAPI</span> <span class=nf>UnhandledExcepFilter</span><span class=p>(</span><span class=n>PEXCEPTION_POINTERS</span> <span class=n>pExcepPointers</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>SetUnhandledExceptionFilter</span><span class=p>((</span><span class=n>LPTOP_LEVEL_EXCEPTION_FILTER</span><span class=p>)</span><span class=n>pExcepPointers</span><span class=o>-&gt;</span><span class=n>ContextRecord</span><span class=o>-&gt;</span><span class=n>Eax</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>pExcepPointers</span><span class=o>-&gt;</span><span class=n>ContextRecord</span><span class=o>-&gt;</span><span class=n>Eip</span> <span class=o>+=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>EXCEPTION_CONTINUE_EXECUTION</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>EXCEPTION_POINTERS構造体を使用することができるのでContextの値をコントロールすることが可能である。</p><p>EIPを取得して現在のEIPの位置を2だけ増加させてから次の処理を実行するように記述した。</p><p>EIPは現在事項されているコードのアドレスが入っているレジスタである。</p><p>それを2だけ増やしたということはポインターを2だけ増加させたことになる。</p><p>例外が発生している状態ではEIPは例外が発生した場所になる。</p><p>するとポインターが移動しretnに飛ばされる。</p><p>つまり例外が発生したコードをスキップしその次の正常なコードに移動させるコードとなる。</p><p>最初の__tryを用いた手法よりも若干高度になった。</p><p>あとは__tryを用いたときと同様に書けばデバッグを回避することができる。</p><h2 id=0xccそのものを検出する>0xCCそのものを検出する<a hidden class=anchor aria-hidden=true href=#0xccそのものを検出する>#</a></h2><p>int 3の値である0xCCについて深堀する。</p><p>ユーザレベルのデバッガを使用するとブレークポイントを必ず設定することになる。</p><p>ブレークポイントは割り込み3番でオペコードは0xCCになる。</p><p>このためデバッグ中の場合は必ず現在のEIPに0xccが入るのでそれをチェックする方法もある。</p><p>0xCCが入るとコード領域の部分のハッシュ値が変更されるのでハッシュ値を検査する方法でもデバッグ中か判断できる。</p><h2 id=pebを利用した方法>PEBを利用した方法<a hidden class=anchor aria-hidden=true href=#pebを利用した方法>#</a></h2><p>プロセス内部のフラグ情報を利用して現在のプログラムがデバッグ中華判断する方法。</p><p>PEBにはプロセスオブジェクトのいくつかの情報が入っている。</p><p>代表的なものとしてイメージベースアドレス、ヒープマネージャ、DLL関連の情報などがはいっている。</p><p>デバッグ関連情報もこの構造体を通じて確認可能。</p><p>PEB構造体にアクセスするといくつかのメンバー変数の値を用いて現在のプログラムがデバッグ中かどうか判断できる。</p><p>PEBはユーザプロセス空間に入っているがFSレジスタを利用して簡単に求めることができる。</p><p>デバッグの検出方法はBeingDebuggedメンバー変数を取得する方法である。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>mov</span> <span class=n>eax</span><span class=p>,</span> <span class=nl>fs</span><span class=p>:[</span><span class=mi>30</span><span class=n>h</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>mov</span> <span class=n>eax</span><span class=p>,</span> <span class=n>byte</span><span class=p>[</span><span class=n>eax</span><span class=o>+</span><span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>test</span> <span class=n>eax</span><span class=p>,</span> <span class=n>eax</span>
</span></span><span class=line><span class=cl><span class=n>jne</span> <span class=err>@</span><span class=n>DebuggerDetected</span>
</span></span></code></pre></div><p>fs:[30h] がPEBでありその0x2番目のメンバがBeingDebuggedである。</p><p>IsDebuggerPresentと同じ内容。</p><p>次はPEBの0x68番目のメンバ変数である <code>NtGlobalFlag</code> を利用する方法である。</p><p>プロセスが生成されたあと、システムでは各プロセスに対していくつかフラグを設定するがNtGlobalFlagの場合にはデバッグ中でない場合は0、デバッグ中の場合は0x70という値が設定される。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>mov</span> <span class=n>eax</span><span class=p>,</span> <span class=nl>fs</span><span class=p>:[</span><span class=mi>30</span><span class=n>h</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>mov</span> <span class=n>eax</span><span class=p>,</span> <span class=p>[</span><span class=n>eax</span><span class=o>+</span><span class=mi>68</span><span class=n>h</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>and</span> <span class=n>eax</span><span class=p>,</span> <span class=mh>0x70</span>
</span></span><span class=line><span class=cl><span class=n>test</span> <span class=n>eax</span><span class=p>,</span> <span class=n>eax</span>
</span></span><span class=line><span class=cl><span class=n>jne</span> <span class=err>@</span><span class=n>DebuggerDetected</span>
</span></span></code></pre></div><p>上記コードで検知できる。</p><p>3番目はヒープフラグを使用した方法である。</p><p>仕組みはBeingDebuggedやNtGlobalFlagと同様である。</p><p>PEBにアクセスしたあとProcessHeapに対応する構造体のアドレスを取得し、その値を比較してデバッグ中であるか確認する。</p><p>ProcessHeapはHANDLE型なのでHEAP構造体にもう一度アクセスしなければならない。</p><p>プロセスのヒープが生成されるとき0xcと0x10の位置にFlags, ForceFlagsのメンバがあることがわかる。また、それぞれ2,0の値が入る。</p><p>しかしデバッグ中はそれぞれ0x50000062と0x40000060に変わる。</p><p>この規則性を利用して確認すればデバッグ中か確認できる。</p><p>Flagsの場合</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>mov</span> <span class=n>eax</span><span class=p>,</span> <span class=nl>fs</span><span class=p>:[</span><span class=mi>30</span><span class=n>h</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>mov</span> <span class=n>eax</span><span class=p>,</span> <span class=p>[</span><span class=n>eax</span><span class=o>+</span><span class=mi>18</span><span class=n>h</span><span class=p>];</span> <span class=n>process</span> <span class=n>heap</span>
</span></span><span class=line><span class=cl><span class=n>cmp</span> <span class=n>dword</span> <span class=p>[</span><span class=n>eax</span><span class=o>+</span><span class=mh>0x0c</span><span class=p>],</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=n>jne</span> <span class=p>.</span><span class=n>debugger_found</span>
</span></span></code></pre></div><p>ForceFlagsの場合</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>mov</span> <span class=n>eax</span><span class=p>,</span> <span class=p>[</span><span class=n>eax</span><span class=o>+</span><span class=mi>10</span><span class=n>h</span><span class=p>];</span> <span class=n>force</span> <span class=n>flags</span>
</span></span><span class=line><span class=cl><span class=n>test</span> <span class=n>eax</span><span class=p>,</span> <span class=n>eax</span>
</span></span><span class=line><span class=cl><span class=n>jne</span> <span class=err>@</span><span class=n>DebuggerDetected</span>
</span></span></code></pre></div><h2 id=プロセスのチェック>プロセスのチェック<a hidden class=anchor aria-hidden=true href=#プロセスのチェック>#</a></h2><p>プロセスを列挙する。</p><p>Process32First/Process32Nextを用いることでデバッガのプロセスを見つけることができる。</p><h2 id=バージョンチェック>バージョンチェック<a hidden class=anchor aria-hidden=true href=#バージョンチェック>#</a></h2><p>現在実行中のプロセスのバージョン情報を取得しそれがデバッガなどの値と一致すればデバッグ中であると判断できる。</p><p>OllyDBGなどではアンチでバッグを避けるためにファイルをパッキングしたりウィンドウの文字列を変更したり実行ファイル名を変更することはあるがバージョン情報を書き換えることは少ない。</p><p>バージョン情報は <code>VerQueryValue</code> というAPIを呼び出すことでバージョンを調べることができる。</p><h2 id=親プロセスのチェック>親プロセスのチェック<a hidden class=anchor aria-hidden=true href=#親プロセスのチェック>#</a></h2><p>プロセスを実行させた主体がどのプロセス化チェックする方法。</p><p>システムで実行されるプロセスはそのプロセスを実行させた親プロセスが存在する。</p><p>たとえばエクスプローラからメモ帳を起動すると子プロセスのnotepad.exeの親プロセスはexplorer.exeになる。</p><p><code>ToolHelp32</code> ライブラリを利用すると <code>PROCESSENTRY32</code> という構造体の中に <code>th32ParentProcessID</code> という名前の変数がある。</p><p>この変数の中に親プロセスのPIDが含まれているので親プロセスのPIDが explorer.exeやcmd.exe出ない場合はデバッグ中だと判断できる。</p><h2 id=sedebugprivilege-権限チェック>SeDebugPrivilege 権限チェック<a hidden class=anchor aria-hidden=true href=#sedebugprivilege-権限チェック>#</a></h2><p>プロセスのデバッグ中はSeDebugPrivilege権限を使用することになる。</p><p>したがってSeDebugPrivilege権限を得た場合、システムプロセスの一つである csrss.exe のプロセスのハンドルが取得できるのでこれを取得できるかどうかに着目した方法をアンチでバッグに利用できる。</p><p>csrss.exeのプロセスをOpenProcess()で開いてハンドルが取得できたら現在のプロセスはSeDebugPrivilege権限を得ていると仮定し、デバッガーによって実行されていると判断できる。</p><p>Tool Help LibraryでProcess32Nextでループを回って取得しても良いが、ntdll.dllにはCsrGetProcessIdというAPIがある。この関数を用いるとcsrss.exeのPIDを取得する。</p><p>これをOpenPorcess関数の引数として私PROCESS_ALL_ACCESS権限でプロセスハンドルを取得できればデバッグされていると判断できる。</p><h2 id=windbgの検出>WINDBGの検出<a hidden class=anchor aria-hidden=true href=#windbgの検出>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>WindbgClassNameDetect</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>HANDLE</span> <span class=n>hWinDbg</span> <span class=o>=</span> <span class=o>::</span><span class=n>FindWindow</span><span class=p>(</span><span class=s>&#34;WinDbgFrameClass&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>hWinDbg</span><span class=p>)</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>WinDBGはWinDbgFrameClassというクラス名を持っているのでそのクラス名でハンドルを見つけることで検出可能である。</p><h2 id=キーボード入力のブロック>キーボード入力のブロック<a hidden class=anchor aria-hidden=true href=#キーボード入力のブロック>#</a></h2><p>リバースエンジニアリング、デバッグ時にキーボードやマウスの操作をできなくする。</p><p>BlockInput() というWin32 APIがその役割を果たす。引数にTRUEを渡すとキーボードやマウス入力がブロックされ、FALSEを渡して再び呼び出すと入力が可能になる。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>BlockAllControl</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>typedef</span> <span class=n>BOOL</span> <span class=p>(</span><span class=kr>__stdcall</span> <span class=o>*</span><span class=n>TBLOCKINPUT</span><span class=p>)(</span><span class=n>BOOL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>TBLOCKINPUT</span> <span class=n>fnBlockInput</span> <span class=o>=</span> <span class=p>(</span><span class=n>TBLOCKINPUT</span><span class=p>)</span><span class=n>GetProcAddress</span><span class=p>(</span><span class=n>GetModuleHandle</span><span class=p>(</span><span class=s>&#34;user32.dll&#34;</span><span class=p>),</span> <span class=s>&#34;BlockInput&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fnBlockInput</span><span class=p>(</span><span class=n>TRUE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>sleep</span><span class=p>(</span><span class=mi>5000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fnBlockInput</span><span class=p>(</span><span class=n>FALSE</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>5秒間マウスとキーボードの動きを止めるサンプル。</p><h2 id=時間差攻撃>時間差攻撃<a hidden class=anchor aria-hidden=true href=#時間差攻撃>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>DWORD</span> <span class=nf>TimeCheck</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span> <span class=n>dwStart</span> <span class=o>=</span> <span class=n>GetTickCount</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=n>a</span> <span class=o>^</span> <span class=mh>0x369</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>d</span> <span class=o>=</span> <span class=n>c</span> <span class=o>+</span> <span class=n>b</span> <span class=o>*</span> <span class=mh>0xdead</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>e</span> <span class=o>=</span> <span class=n>d</span> <span class=o>/</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span> <span class=n>dwEnd</span> <span class=o>=</span> <span class=n>GetTickCount</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>dwEnd</span> <span class=o>-</span> <span class=n>dwStart</span> <span class=o>&gt;</span> <span class=mi>1000</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>e</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>リバースエンジニアリングしているときは1秒以上実行に時間がかかるはずなのでデバッグ中であると判断できる。</p><p>rdtscを利用した方法はWinAPIを使用しないので比較的強力である。</p><h2 id=prefix-rep-による例外処理>PREFIX REP による例外処理<a hidden class=anchor aria-hidden=true href=#prefix-rep-による例外処理>#</a></h2><p>例外ハンドラに送るものと似たような方法。</p><p>インラインアセンブラでprefix値を追加するとデバッグ中とそうでないときで実行のされ方が異なることを利用した方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>IsDbgPresentPrefixCheck</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>__try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>__asm</span> <span class=n>__emit</span> <span class=mh>0xF3</span>
</span></span><span class=line><span class=cl>    <span class=kr>__asm</span> <span class=n>__emit</span> <span class=mh>0x64</span>
</span></span><span class=line><span class=cl>    <span class=kr>__asm</span> <span class=n>__emit</span> <span class=mh>0xF1</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kr>__except</span><span class=p>(</span><span class=n>EXCEPTION_EXECUTE_HANDLER</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// debugger not found
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>__asm 似続けて __emit を入力してからオペコードを入れると0xF3という値がバイナリにそのまま埋め込まれる。すなわちこのコードのようにアセンブラコードを3業入れるとバイナリには次のように記録される。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>F3</span> <span class=mi>64</span> <span class=c1>// prefix rep
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>F1</span>  <span class=c1>// int 1
</span></span></span></code></pre></div><p>prefix rep命令は本来はリピートの用途で使用されるが、この命令を上記のように作成しておいてしうぐにint 1を呼び出すとデバッグ中には正常に動作しない。</p><p>通常の状況であれば次のステップに進みint 1で例外ハンドラに移るのだが、現在のプログラムがデバッグ中である場合はハンドラに進まず return true;に進むのでデバッグ中だと判断することができる。</p><p>コードがこのように動く理由は pop ss が実行されると CPU はスタックが壊れないように割り込み発生を防ぐからである。</p><p>このためシングルステップトレースでフラグを設定しても無視されて結局デバッガでは実行されてしまい検出できなくなる。</p><p>アセンブラコードの影響で少し複雑に見えるが例外ハンドラを利用した分岐の延長だと思えば簡単だ。</p><h2 id=api-フックを利用したデバッグ検出>API フックを利用したデバッグ検出<a hidden class=anchor aria-hidden=true href=#api-フックを利用したデバッグ検出>#</a></h2><p>APIフックを利用してアンチでバッグ機能を実現することができる。</p><p>デバッガをプイロセスにあタッチする際、内部的にDebugActiveProcess() というAPIを利用する。</p><p>このAPIを無力化するとアタッチ自体が不可能になるためデバッグとリバーシングが困難になる。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>BOOL</span> <span class=n>DebugActiveProcess</span><span class=p>(</span><span class=n>DWORD</span> <span class=n>dwProcessId</span><span class=p>)</span>
</span></span></code></pre></div><p>BOOL 変数であるためこのAPIをブロックするにはFALSEを返すだけで良い。</p><p>戻りちはEAXに入るため、EAXに値を入れてリターンさせるコードをDebugActiveProcess()のエントリポイントに入力しよう。</p><p>DbgUiRemoteBreakinやOpenProcess, ReadProcessMemory, WriteProcessMemoryを無力化してデバッガでプロセスの情報を得られないようにすることができる。</p><p>DbgUiRemoteBreakinカーネルではKiMoveApcState, KeStackAttachProcessなどのAPIを制御してプロセスのあタッチをより低いレベルで管理することができる。</p><h2 id=リモートでバッグの検出>リモートでバッグの検出<a hidden class=anchor aria-hidden=true href=#リモートでバッグの検出>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>BOOL</span> <span class=nf>IsRemoteDebugger</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>BOOL</span> <span class=n>bDetection</span> <span class=o>=</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>KdRefreshDebuggerNotPresent</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>KD_DEBUGGER_NOT_PRESENT</span> <span class=o>==</span> <span class=n>FALSE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>bDetection</span> <span class=o>=</span> <span class=n>TRUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DbgPrint</span><span class=p>(</span><span class=s>&#34;Debugger attached&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DbgPrint</span><span class=p>(</span><span class=s>&#34;Debugger Not Attached&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>bDetection</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://famasoon.github.io/posts/proxyingdll/><span class=title>« Prev</span><br><span>DLL proxying with Rust</span>
</a><a class=next href=https://famasoon.github.io/posts/amsibypass/><span class=title>Next »</span><br><span>AMSI bypass</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Anti-debug introduction on x" href="https://x.com/intent/tweet/?text=Anti-debug%20introduction&amp;url=https%3a%2f%2ffamasoon.github.io%2fposts%2fantidebug%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Anti-debug introduction on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ffamasoon.github.io%2fposts%2fantidebug%2f&amp;title=Anti-debug%20introduction&amp;summary=Anti-debug%20introduction&amp;source=https%3a%2f%2ffamasoon.github.io%2fposts%2fantidebug%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Anti-debug introduction on reddit" href="https://reddit.com/submit?url=https%3a%2f%2ffamasoon.github.io%2fposts%2fantidebug%2f&title=Anti-debug%20introduction"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Anti-debug introduction on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ffamasoon.github.io%2fposts%2fantidebug%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Anti-debug introduction on whatsapp" href="https://api.whatsapp.com/send?text=Anti-debug%20introduction%20-%20https%3a%2f%2ffamasoon.github.io%2fposts%2fantidebug%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Anti-debug introduction on telegram" href="https://telegram.me/share/url?text=Anti-debug%20introduction&amp;url=https%3a%2f%2ffamasoon.github.io%2fposts%2fantidebug%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Anti-debug introduction on ycombinator" href="https://news.ycombinator.com/submitlink?t=Anti-debug%20introduction&u=https%3a%2f%2ffamasoon.github.io%2fposts%2fantidebug%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://famasoon.github.io/>x64.moe</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>