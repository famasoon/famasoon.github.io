<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.120.4"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>x64.moe</title>
<meta name=keywords content="Blog,Portfolio"><meta name=description content="FAMASoon's blog"><meta name=author content="FAMASoon"><link rel=canonical href=https://famasoon.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><link rel=icon href=https://famasoon.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://famasoon.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://famasoon.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://famasoon.github.io/apple-touch-icon.png><link rel=mask-icon href=https://famasoon.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://famasoon.github.io/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZJPXHR8YPR"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZJPXHR8YPR",{anonymize_ip:!1})}</script><meta property="og:title" content="x64.moe"><meta property="og:description" content="FAMASoon's blog"><meta property="og:type" content="website"><meta property="og:url" content="https://famasoon.github.io/"><meta property="og:image" content="https://famasoon.github.io/static/famasoon.jpg"><meta property="og:site_name" content="x64.moe"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://famasoon.github.io/static/famasoon.jpg"><meta name=twitter:title content="x64.moe"><meta name=twitter:description content="FAMASoon's blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"x64.moe","url":"https://famasoon.github.io/","description":"FAMASoon\u0026#39;s blog","thumbnailUrl":"https://famasoon.github.io/favicon.ico","sameAs":["https://twitter.com/FAMASoon","https://github.com/famasoon"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://famasoon.github.io/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://famasoon.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://famasoon.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class="first-entry home-info"><header class=entry-header><h1>x64.moe 👋</h1></header><div class=entry-content>Welcome to FAMASoon&rsquo;s blog</div><footer class=entry-footer><div class=social-icons><a href=https://twitter.com/FAMASoon target=_blank rel="noopener noreferrer me" title=Twitter><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a href=https://github.com/famasoon target=_blank rel="noopener noreferrer me" title=Github><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></footer></article><article class=post-entry><header class=entry-header><h2>DLL proxying with Rust</h2></header><div class=entry-content><p>DLL proxying with Rust what is dll proxying? DLL proxying, also known as DLL redirection or DLL hijacking, is a technique used by attackers or developers to manipulate the way Windows loads dynamic link libraries (DLLs). DLLs are files that contain code and data that multiple programs can use simultaneously. They provide a way to modularize code and promote code reuse.
DLL proxying involves placing a malicious or modified DLL in a location that is searched by a target application before the legitimate DLL is located....</p></div><footer class=entry-footer>&lt;span title='2023-11-23 00:00:00 +0000 UTC'>November 23, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;3 min&amp;nbsp;·&amp;nbsp;521 words&amp;nbsp;·&amp;nbsp;FAMASoon</footer><a class=entry-link aria-label="post link to DLL proxying with Rust" href=https://famasoon.github.io/posts/proxyingdll/></a></article><article class=post-entry><header class=entry-header><h2>Anti-debug introduction</h2></header><div class=entry-content><p>Anti-debug アンチデバッグのやり方はたくさんあるが、その中でもよく使われるものを紹介する。
網羅的に把握したい場合は下記リンクを参照すると良い。
https://unprotect.it/category/anti-debugging/
古典的なアンチデバッグ bool FindDebugger() { bool bDetect = false; HWND hDebugger = ::FindWindow(NULL, "OllyDBG"); if (hDebugger) { bDetect = true; AfxMessageBox("Can not use debugger"); } return bDetect; } デバッガーのウィンドウキャプションを見つけてプログラムを終了させる。
IsDebuggerPresent MSDNに記載されていてkernel32.dllから提供されている。
if (IsDebuggerPresent()) { exit(1); } アセンブリになると下記のようになる
mov eax, dword ptf fs:[18] mov eax, dword ptr ds:[eax+30] movzx eax, byte ptr ds:[eax+2] retn fs:[18] はTEBを指す。(Thread Environment Block)
TEBをEAXに入れたがそこから30番地離れたアドレスを再びEAXに入力するコードだ。
TEBから0x30離れたところにはPEB(Process Environment Block) がある。
EAXにはPEBが入っていて、そこから+2移動したアドレスから1バイト持ってきていると解釈できる。
PEBの構造体は下記の通り。
typedef struct _PEB { BYTE Reserved1[2]; BYTE BeingDebugged; BYTE Reserved2[1]; PVOID Reserved3[2]; PPEB_LDR_DATA Ldr; PRTL_USER_PROCESS_PARAMETERS ProcessParameters; PVOID Reserved4[3]; PVOID AtlThunkSListPtr; PVOID Reserved5; ULONG Reserved6; PVOID Reserved7; ULONG Reserved8; ULONG AtlThunkSListPtr32; PVOID Reserved9[45]; BYTE Reserved10[96]; PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine; BYTE Reserved11[128]; PVOID Reserved12[1]; ULONG SessionId; } PEB, *PPEB; BeingDebugged という名前の箇所の値を入れている。...</p></div><footer class=entry-footer>&lt;span title='2023-10-12 00:00:00 +0000 UTC'>October 12, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;5 min&amp;nbsp;·&amp;nbsp;854 words&amp;nbsp;·&amp;nbsp;FAMASoon</footer><a class=entry-link aria-label="post link to Anti-debug introduction" href=https://famasoon.github.io/posts/antidebug/></a></article><article class=post-entry><header class=entry-header><h2>AMSI bypass</h2></header><div class=entry-content><p>スキャン要求を失敗させるために、すでにメモリにロードされているAMSI ライブラリ自体のコードを改ざんする. メモリにすでにロードされている AmsiScanBuffer というライブラリを探し出し、そのアドレスの命令を上書きしてエラーメッセージを表示させます。この攻撃では、マルウェアがメモリ内のライブラリ「AmsiScanBuffer」を探し出し、そのアドレスの命令を、エラーメッセージにリダイレクトする新しい命令で上書きします。
[package] name = "amsibypass" version = "0.1.0" edition = "2021" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [[bin]] name = "amsi_bypass" path = "src/main.rs" [dependencies] winapi = {version = "0.3.9", features=["memoryapi", "libloaderapi", "processthreadsapi"]} win32-error = "0.9.0" use std::{ffi::CString, ptr}; use winapi::{ um::{ memoryapi::{ VirtualProtect, WriteProcessMemory }, libloaderapi::{ LoadLibraryA, GetProcAddress }, processthreadsapi::GetCurrentProcess, winnt::PAGE_READWRITE }, shared::{ minwindef::{ DWORD, FALSE }, ntdef::NULL } }; fn main() { println!...</p></div><footer class=entry-footer>&lt;span title='2023-10-11 00:00:00 +0000 UTC'>October 11, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;167 words&amp;nbsp;·&amp;nbsp;FAMASoon</footer><a class=entry-link aria-label="post link to AMSI bypass" href=https://famasoon.github.io/posts/amsibypass/></a></article><article class=post-entry><header class=entry-header><h2>Offensive Rustのレビュー</h2></header><div class=entry-content><p>Offensive Rust かんたんなまとめ: Rustでレッドチームシミュレータを書きたい人におすすめ。
リンク https://redteamsorcery.teachable.com/courses/enrolled/1973492
https://www.udemy.com/course/offensive-rust/
アフィリエイトはないです。
概要 本教材ではオフェンシブなコード、レッドチーム向けのコードをRustで書いていく。
なお、対象環境はWindows。
WSLとかではなくWindowsに直接Rustをインストールする。
内容 内容はかなり多岐にわたる。
最初の方ではRustのセットアップを実施し、基礎的なRustの書き方を教えてくれる。
中盤からはオフェンシブなコードを書いていく。
例えばLDAPを用いたActive Directoryの列挙であったり、シェルコードを書いたり、DLLインジェクションを行ったりと、基本的なRustの書き方を抑えつつレッドチーム向けのコードを書いていく。
また、Reflective PE Loaderを書いたり、Process Hollowingをやったり、ハッシュ化した関数呼び出しをしたりとレッドチームシミュレータで実行しそうな内容をRustでどのように書くか教えてくれる。
以降もAMSIのバイパスの仕方やProcess Doppelgangingの仕方をRustで解説してくれる。
総じてレッドチームシミュレータをRustで書いてみたいと方にはおすすめの内容。
各パートは体感ではそこまで長くなく、サッと書いてサッと試すということをやっていく。
まとめ レッドチーム向けのシミュレータを書きたいとなったとき、候補としてはC/C++が挙がるがRustで書きたい人は、この教材を買って見てみると良いだろう。</p></div><footer class=entry-footer>&lt;span title='2023-10-11 00:00:00 +0000 UTC'>October 11, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;28 words&amp;nbsp;·&amp;nbsp;FAMASoon</footer><a class=entry-link aria-label="post link to Offensive Rustのレビュー" href=https://famasoon.github.io/posts/offensiverustreview/></a></article><article class=post-entry><header class=entry-header><h2>PEについてメモ</h2></header><div class=entry-content><p>What is PE PEファイルとはPortable Executable File Formatの略。
ポータブルな実行ファイルである。
ビルド たとえばtest.cppといったファイルを作成してビルドすると、まず関連するヘッダーとソースをコンパイルし1つの機械語コードを作成する。
この段階でReleaseディレクトリにobjファイルが生成される。
次にリンク作業が行われる。
リンカはOSでこのファイルを実行できるように動的ライブラリや様々なリソースデータ、インポート・エクスポートテーブルを処理するための情報をファイルに書き出す。
この際にWindowsは決まったルールに沿って情報を用意しExeファイルを作成する際に、ヘッダーに情報を書き込む。
これがPEフォーマットを作成する処理である。
PEヘッダーの中には実行ファイルを実行するために様々な情報が記録されている。
PEファイルの構造 IMAGE_DOS_HEADER IMAGE_NT_HEADER IMAGE_FILE_HEADER IMAGE_OPTIONAL_HEADER IMAGE_SECTION_HEADER IMAGE_IMPORT_DESCRIPTOR IMAGE_EXPORT_DIRECTORY IMAGE_IMPORT_BY_NAME IMAGE_THUNK_DATA32 主要な構造体は上記の通り。
IMAGE_DOS_HEADER typedef struct _IMAGE_DOS_HEADER { // DOS .EXE header WORD e_magic; // Magic number WORD e_cblp; // Bytes on last page of file WORD e_cp; // Pages in file WORD e_crlc; // Relocations WORD e_cparhdr; // Size of header in paragraphs WORD e_minalloc; // Minimum extra paragraphs needed WORD e_maxalloc; // Maximum extra paragraphs needed WORD e_ss; // Initial (relative) SS value WORD e_sp; // Initial SP value WORD e_csum; // Checksum WORD e_ip; // Initial IP value WORD e_cs; // Initial (relative) CS value WORD e_lfarlc; // File address of relocation table WORD e_ovno; // Overlay number WORD e_res[4]; // Reserved words WORD e_oemid; // OEM identifier (for e_oeminfo) WORD e_oeminfo; // OEM information; e_oemid specific WORD e_res2[10]; // Reserved words LONG e_lfanew; // File address of new exe header } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; e_magic , e_lfanew について注目するとよい。...</p></div><footer class=entry-footer>&lt;span title='2023-07-21 00:00:00 +0000 UTC'>July 21, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;3 min&amp;nbsp;·&amp;nbsp;590 words&amp;nbsp;·&amp;nbsp;FAMASoon</footer><a class=entry-link aria-label="post link to PEについてメモ" href=https://famasoon.github.io/posts/whatispe/></a></article><article class=post-entry><header class=entry-header><h2>LibFuzzerを使った</h2></header><div class=entry-content><p>LibFuzzerを使った https://x64.moe/posts/whatslibfuzzer/ こんな感じにファジングできるLibFuzzerを使ってみた。 結論としてはどれもうまくいかなかった(クラッシュしない・クラッシュしても配布されるビルドのものだとクラッシュしない等など)
ターゲット Jansson https://github.com/akheron/jansson なんかのパーサがやりやすいかなと思ってJSONパーサのJanssonを選んだ。
#include &lt;stddef.h> #include &lt;stdint.h> #include "jansson.h" int parseJson(const char *buffer, size_t buflen) { json_error_t error; json_t *root; json_t *obj; const char *str; double dValue; int iValue; root = json_loadb(buffer, buflen, 0, &amp;error); if (root == NULL) { return 0; } obj = json_object_get(root, "dateTime"); if (json_is_string(obj)) { str = json_string_value(obj); } obj = json_object_get(root, "eventType"); if (json_is_string(obj)) { str = json_string_value(obj); } obj = json_object_get(root, "DependOnSequentialEvent"); if (json_is_object(obj)) { json_t *obj2; obj2 = json_object_get(obj, "valPercent"); if (json_is_real(obj2)) { dValue = json_real_value(obj2); } else if (json_is_integer(obj2)) { iValue = json_integer_value(obj2); } obj2 = json_object_get(obj, "alive"); if (json_is_string(obj2)) { str = json_string_value(obj2); } obj2 = json_object_get(obj, "isScript"); } return 0; } extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) { if (size &lt; 0) { return -1; } parseJson((const char *)data, size); return 0; } ビルド内容は下記のような感じ クラッシュしなかった。...</p></div><footer class=entry-footer>&lt;span title='2023-07-04 00:00:00 +0000 UTC'>July 4, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;2 min&amp;nbsp;·&amp;nbsp;306 words&amp;nbsp;·&amp;nbsp;FAMASoon</footer><a class=entry-link aria-label="post link to LibFuzzerを使った" href=https://famasoon.github.io/posts/libfuzzerfail/></a></article><article class=post-entry><header class=entry-header><h2>LibFuzzer's Example</h2></header><div class=entry-content><p>What is LibuFuzzer? Libfuzzer is a library part of LLVM that can be used to fuzz test programs.
Example Build the fuzzing target.
#include &lt;stdint.h> #include &lt;stddef.h> bool FuzzMe(const uint8_t *Data, size_t DataSize) { return DataSize >= 3 && Data[0] == 'F' && Data[1] == 'U' && Data[2] == 'Z' && Data[3] == 'Z'; } extern "C" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) { FuzzMe(Data, Size); return 0; } First, write LLVMFuzzerTestOneInput function....</p></div><footer class=entry-footer>&lt;span title='2023-06-29 00:00:00 +0000 UTC'>June 29, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;4 min&amp;nbsp;·&amp;nbsp;805 words&amp;nbsp;·&amp;nbsp;FAMASoon</footer><a class=entry-link aria-label="post link to LibFuzzer's Example" href=https://famasoon.github.io/posts/whatslibfuzzer/></a></article><article class=post-entry><header class=entry-header><h2>[Note] LibAFLとはなにか</h2></header><div class=entry-content><p>LibAFL とは https://aflplus.plus/libafl-book/libafl.html ファジングのためのライブラリ。 AFL, libFuzzer, honggfuzz といったファザーは存在するが拡張性がない。 個々のソフトウェアに対してカスタマイズ可能なファザーを作るために開発された。
特徴 マルチプラットフォーム対応 OS依存のランタイムを必要としていない なので組み込みデバイスやハイパーバイザ、WASMなどにつかえる(らしい) AFLPlusPlusで培った経験が活かされている スケールしやすいらしい 早い ソフトウェアに合わせてカスタムできる 入門 crate として使える。 注意点としてClangに依存しているので予めインストールする必要がある。
各種プロジェクトのルートディレクトリから cargo build --release を実行することでビルドできる。 下記のように Cargo.toml に書けば良い(私は cargo add で入れた)
[dependencies] libafl = { version = "*" } 色々とカスタムできるがクレートとしては libafl を使えば良さそう。 他のクレートの説明はこちら。 https://aflplus.plus/libafl-book/getting_started/crates.html
コンセプト Observer テスト対象のぷろぐらむの実行を監視し、その情報をファザーに提供するものです。 これは Observer トレイトに書かれている。 各ファジングのデータを保持したりファジングケースの前後でフックしたりできる。
Executor テスト対処の実行に関する操作を定義するもの。 ファザー＝が実行で使用したい入力についてプログラムに通知し、特定のメモリの場所に書き込んだり、それをパラメータとしてハーネスに渡す責任がある。 Executor トレイとで提供されている。 InprocessExecutor はプロセス内のクラッシュを検出する。 ForkserverExecutor 子プロセスをファズするときに使う。
InprocessExecotr はファザープロセス内のハーネスを実行する。 ハーネスをできるだけ早く実行したいときはこれを採用する。 注意するべき点はハーネスにヒープ周りのバグがある可能性がある場合、クラッシュしたヒープがファザーに影響を与えないように別のアロケータを使用する必要があります。 例えばMiMallocを使用するなど。 あるいはアドレスサニタイザーを使用してハーネスをコンパイルしヒープ周りのバグを補足できるようにする。
ForkserverExecutor は共有メモリを使用してハーネスを実行する。
InprocessForkExecutor はハーネスを実行する前に分岐する。 ハーネスが不安定になったりクラッシュするような場合、子プロセスでハーネスを実行する必要がある。 そのような時に使用する。 ただしハーネスを実行し、カバレッジをマップに書くのは子プロセス。 親プロセスと子プロセスの間でマップを共有するために共有メモリを使用する。...</p></div><footer class=entry-footer>&lt;span title='2023-06-10 00:00:00 +0000 UTC'>June 10, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;104 words&amp;nbsp;·&amp;nbsp;FAMASoon</footer><a class=entry-link aria-label="post link to [Note] LibAFLとはなにか" href=https://famasoon.github.io/posts/libafl/></a></article><article class=post-entry><header class=entry-header><h2>Dll Injection with Rust</h2></header><div class=entry-content><p>winapi winapi provides raw FFI bindings to all of Windows API. So, I will use this crate.
code When run command cargo run, it can be inject dll to process
use winapi::ctypes::*; use winapi::um::libloaderapi::{GetModuleHandleA, GetProcAddress}; use winapi::um::memoryapi::{VirtualAllocEx, WriteProcessMemory}; use winapi::um::processthreadsapi::{CreateRemoteThread, OpenProcess}; pub fn DllInject(proc_handle: *mut c_void, dll_path: &amp;str) { unsafe { let remote_base = VirtualAllocEx( proc_handle, std::ptr::null_mut(), dll_path.len(), 0x1000, 0x40, ); WriteProcessMemory( proc_handle, remote_base, dll_path.as_bytes().as_ptr() as *const c_void, dll_path.len(), std::ptr::null_mut(), ); let dll_handle = GetModuleHandleA("kernel32....</p></div><footer class=entry-footer>&lt;span title='2023-06-06 00:00:00 +0000 UTC'>June 6, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;129 words&amp;nbsp;·&amp;nbsp;FAMASoon</footer><a class=entry-link aria-label="post link to Dll Injection with Rust" href=https://famasoon.github.io/posts/dllinjectionwithrust/></a></article><article class=post-entry><header class=entry-header><h2>Executing functions in Rust with winapi</h2></header><div class=entry-content><p>Motivation I want to how to allocate memory on windows and execute code in buffers.
winapi winapi provides raw FFI bindings to all of Windows API. So, I will use this crate.
code When run command cargo run, popup calc.exe
use std::mem::transmute; use winapi::um::errhandlingapi::GetLastError; use winapi::um::memoryapi::VirtualAlloc; use winapi::um::processthreadsapi::CreateThread; use winapi::um::synchapi::WaitForSingleObject; fn main() { let buffer: [u8; 276] = [ 0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x0f, 0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52, 0x20, 0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44, 0x8b, 0x40, 0x20, 0x49, 0x01, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41, 0x8b, 0x34, 0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 0x75, 0xf1, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 0x75, 0xd8, 0x58, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44, 0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01, 0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 0x58, 0x41, 0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x57, 0xff, 0xff, 0xff, 0x5d, 0x48, 0xba, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x8d, 0x01, 0x01, 0x00, 0x00, 0x41, 0xba, 0x31, 0x8b, 0x6f, 0x87, 0xff, 0xd5, 0xbb, 0xe0, 0x1d, 0x2a, 0x0a, 0x41, 0xba, 0xa6, 0x95, 0xbd, 0x9d, 0xff, 0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c, 0x0a, 0x80, 0xfb, 0xe0, 0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a, 0x00, 0x59, 0x41, 0x89, 0xda, 0xff, 0xd5, 0x63, 0x61, 0x6c, 0x63, 0x2e, 0x65, 0x78, 0x65, 0x00, ]; unsafe { let baseptr = VirtualAlloc(std::ptr::null_mut(), buffer....</p></div><footer class=entry-footer>&lt;span title='2023-06-04 00:00:00 +0000 UTC'>June 4, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;2 min&amp;nbsp;·&amp;nbsp;388 words&amp;nbsp;·&amp;nbsp;FAMASoon</footer><a class=entry-link aria-label="post link to Executing functions in Rust with winapi" href=https://famasoon.github.io/posts/execfuncrustwithwinapi/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://famasoon.github.io/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=https://famasoon.github.io/>x64.moe</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>